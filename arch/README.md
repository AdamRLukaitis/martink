Architecture layer
==================

- Martin K. Schröder - info@fortmax.se

Currently supported architectures
-----------------------

| VENDOR   |    Model      |Status |
|----------|:-------------:|------:|
|   ATMEL  |  ATMega328p   |  yes  |
|   ATMEL  |   AT91SAM3    |  yes  |
|   ST     |   STM32F103   |  part |

When you want to implement support for a new chip, what you would need to do is implement all of the interfaces defined in arch/interface.h file. We will take a look at these interfaces in turn below. But first a little on how things are put together.

The whole arch layer for an architecture can be included into your application by including arch/soc.h file. It will automatically include needed files according to include/autoconfig.h file (generated by 'make menuconfig')

```
#include <arch/soc.h>
```

This layer consists of following devices:

* [ADC](arch_adc.md) - analog to digital converters
* [DAC](arch_dac.md) - digital to analog converters
* [GPIO](arch_gpio.md) - on chip general purpose io driver
* [PWM](arch_pwm.md) - pulse width modulation peripherals       
* [SPI](arch_spi.md) - on board serial peripheral interface peripherals
* [I2C/TWI](arch_twi.md) - i2c interfaces  
* [UART](arch_uart.md) - asynchronous serial interfaces
* [CAN](arch_can.md) - controller area network interfaces

The arch layer is built around the idea of being really fast. Because this is the absolutely lowest layer that is closest to hardware, the methods of this layer get called a lot of times. This layer is responsible for providing a human readable interface to chip register operations.

We would typically implement this layer by wrapping register operations in macro expressions. You can take a look at how this is done in one of the header files found in for instance arch/avr/m328p folder. All cpu operations are wrapped in macros. You don't have to use macros on higher layers, but this layer is usually very simple (ie all "method" calls in this layer really just write values to some memory location) so we actually want to do this with macros. You can for instance look at the implementation of gpio interface in arch/avr/m328p/gpio.h

Devices and their interfaces
----------------------------

There are typically two ways to access devices on the soc. You can either call the arch layer directly (ie call the macros) or you can use generic interfaces that the arch layer can create for you in order to access the devices generically. Generic interfaces are designed to allow interchangable use of many different types of devices that can provide the same kind of service. For example, libc FILE* handle is a type of generic interface. It has get() and put() function pointers that get called by getc/putc. This way you can use FILE* to access a file on any filesystem, you can access a device, you can access a fifo pipe - all thought exactly the same interface.

This is exactly what we want to have for our device drivers as well!

But there is one problem: the devices that we are working with are all flash based controllers that usually have little memory - both flash and ram. We can not use really rich interfaces like the linux kernel. And we don't want to force the user to use interfaces. We want to provide interfaces simply as an essential feature for enabling driver reuse and for adding a great deal of flexibility for how device drivers are used.

You should think of interfaces as "services" that the device provides as opposed to identifying a specific device. If we make all of our devices "service"-oriented, we can reuse device drivers in many different contexts and pipe data from one driver to another. This is exactly the same philosophy that is used by linux commands where you can create more complex commands easily by simply piping results of one command to the next.

| Interface            | Methods             | Usage                |
|----------------------|---------------------|----------------------|
| analog_interface     | read_pin   | Used for any device that can read an analog signal and report it as 16 bit value. Since many adc peripherals have multiple channels, you specify which channel you want to read. How the data is read is up to the implementation. Your actual driver may for example use adc interrupt and read adc in the background and load it into a cache, making your read_pin call return directly. Others may block until the adc value is converted. 
| parallel_interface   | write_pin, write_word, read_pin, read_word, configure_pin, get_pin_status | GPIO interface is for implementing any type of bit wise parallel io. A lot of device can implement this kind of interface - i2c parallel io chips, shift registers that connect over spi, soc gpio pins, etc. Characteristic of this interface is that it consists of arbitrary number of "pins" that can be written and read, as well as configured to have pullups.
| pwm_interface        | set_channel_duty, set_channel_period | PWM interface is for controlling pwm hardware. Usually it would be built in, timer driven pwm channels, but the system does not limit you to just on board pwm channel You could just as easily have a driver for an i2c or spi pwm controller export this kind of interface and this would allow you to pass it to any component that requires a pwm interface (such as for example a motor speed controller). 
| packet_interface     | begin, end, write, read, sync, packets_available | A packet interface is similar to a serial interface but instead operates on chunks of data. Whereas a serial interface guarantees that you either get or not get an individual byte of data, a packet interface does the same for chunks, meaning that you either get or not get a packet - there is no possibility to only get a partial packet.
| serial_interface     | get, put, getn, putn, flush, waiting | A serial interface is any device that is capable of sending and receiving data over some kind of channel. A serial interface is typically a stream it is not a transaction based interface, but rather a stream based one. Data can usually be transfered in both directions and we do not use any  kind of addressing scheme. A serial interface is a point to point channel between two devices.

Here are some examples of what interfaces different core devices can export:

Click on the device name to read more!

| Device               | Interfaces exported    | 
|:---------------------|------------------------|
| [ADC](arch_adc.md)   | analog_interface    		|
| [GPIO](arch_gpio.md) | parallel_interface   	|
| [PWM](arch_pwm.md)   | pwm_interface         	|
| [SPI](arch_spi.md)   | serial_interface      	|
| [I2C](arch_i2c.md)   | packet_interface       |
| [UART](arch_uart.md) | serial_interface       |

Analog to digital converters
----------------------------
Martin K. Schröder | info@fortmax.se

Files:

* arch/manufacturer/model/adc.h
* arch/adc.h

These devices are expected to provide a service of reading an analog signal on one of available pins and reporting the value as a digital 16 bit number. Adc implementation is limited to 256 channels (although can easily be extended in the future if one needs more). An adc driver should typically only control one type of device or a few types of devices that are very similar to each other. If a device differs too much, a separate driver should be created.

Public interface
----------------

| struct analog_interface method | Description |
|--------------------------------|-------------|
int16_t (*read_pin)(adc, pin_number) | reads adc pin and returns it's integer representation. 

Implementation macro guidelines
----------------------

| Method   | Description |
|----------|-------------|
| adc0_enable() | provides means to turn on the adc peripheral
| adc0_disable() | will turn off adc to save power
| adc0_init_default() | configures adc to default settings (typically internal vref, left alignment and slowest possible clock for highest accuracy)
| adc0_set_vref(adcref) | must provide means of setting voltage reference source for the conversion.
| adc0_set_prescaler(adc_clock) | sets adc clock prescaler 
| adc0_set_alignment(adc_align) | must provide means of setting alignment of result (left or right)
| adc0_interrupt_on() | turns on adc interrupt 
| adc0_interrupt_off() | turns off adc interrupt
| adc0_set_channel(adc_chan) | provides means to tell adc peripheral which channel to sample
| adc0_get_channel() | evaluates to whatever channel we are currently sampling
| adc0_start_conversion() | kicks off adc conversion
| adc0_conversion_in_progress() | checks if a conversion is currently in provress
| adc0_wait_for_completed_conversion() | returns when current conversion has finished
| adc0_read() (uint16_t) | simply waits for previous conversion to complete first and then returns sampled value for currently selected channel. 
| adc0_read_immediate(chan) | kicks off a conversion, waits for it to complete and returns the value for supplied channel. 
| adc0_set_mode(adc_mode) | provides access for setting different adc modes (such as manual or automatic continuous mode where data is sampled all the time and cached for future use. Implementation dependent..)

Macros should be provided for every peripheral separately if multiple devices are available - ie adc0, adc1 etc.. 

Typical direct usage
--------------------

```
adc0_init_default();
printf("ADC value: %d\n", adc0_read_immediate(channel_id));
```

For other options it is best to check out implementation specific file in arch/<manufacturer>/<cpu>/adc.h

General purpose parallel interface
----------------------------
Martin K. Schröder | info@fortmax.se

Files:

* arch/manufacturer/model/gpio.h
* arch/gpio.h

A general purpose io is any kind of parallel device where it is possible to address each bit separately and which can be one or more bytes wide. It must be possible to write individual bits separately and also to write full "words" which are as wide as the width of the gpio interface. For internal devices it may be convenient to group all gpio interfaces together so that the user can use a continuous pin indexing scheme (ie for 3x8 bit on board parallel ports the pins can be numbered 0-24 in order to provide a generic way to access the port). 

Public interface
----------------

| parallel_interface | Description |
|--------------------|-------------|
void 		(*write_pin)(struct parallel_interface *self, uint16_t pin_number, uint8_t value) | sets pin of the output port either high or low. 
uint8_t (*read_pin)(struct parallel_interface *self, uint16_t pin_number) | used to read an input pin. Always returns 0 when reading an output pin. 
uint8_t	(*configure_pin)(struct parallel_interface *self, uint16_t pin_number, uint16_t flags) | configure pin to be input, output, pulled up, pulled down etc. Not all options may be supported by implementation. Function returns 0 on success and 1 on failure. 
uint8_t (*get_pin_status)(struct parallel_interface *self, timestamp_t *t_up, timestamp_t *t_down) | used to get status of the pin. Interface allows the implementation to track pin changes in the background and report values to the user of the interface. Returns pin status (went high/low etc.) and writes time in ticks for when pin went high, or went low. You should use time_ticks_to_us() to get interval in us. ticks is a value used for tracking cpu ticks. It only denotes a specific point in time. It is currently easier to keep track of time of the pin changes in the implementation rather than leaving this task to the user. This function is very useful for writing libraries that need to measure pulse intervals. The values of t_up and t_down must be updated by the implementation as way of measuring when the pin went high and when it goes low. Default value returned must be 0. 
uint8_t (*write_word)(struct parallel_interface *self, uint16_t addr, uint32_t value) | used to write byte or int to an io address. If you have pins PA0, PA1 .. PA7 and your registers are 8 bit long then writing to addr 0 should write all of PA pins at the same time. For implementations with larger registers, more bits may be written. This method is used to write multiple bits in one operation. 
uint8_t (*read_word)(struct parallel_interface *self, uint16_t addr, uint32_t *output) | user to read word from an io register. The size of the word depends on the implementation. It may be 8 bit or 16 bit or 32 bit. The size is equivalent to the full size of io registers of implementation. addr is the index of the io register. Implementation must check this value for a valid range and return error if it is invalid.  

Implementation macro guidelines
----------------------

| gpio method | Description |
|-------------|-------------|
gpio_init() | initializes the hardware gpio peripherals
gpio_configure(pin, fun) | provides means to configure pins as input, output, pullup etc. Although not as aux functions, that is the job of the specific aux peripheral driver to set up pins into aux state (ie to connect them to that peripheral) 
gpio_write_word(addr, value) | writes all bits at once on a port specified by addr index. 
gpio_read_word(addr, value) | reads all bits at once from port. 
gpio_write_pin(pin, val) | writes 1 or 0 to a specific pin. GPIO driver should provide all pin definitions as well so that user can easily access pins on the device. 
gpio_read_pin(pin) | reads gpio pin
gpio_clear(pin) | clears a pin (some platforms can do this as one atomic operation!)
gpio_set(pin) | sets a pin
gpio_enable_pcint(pin) | provides means to enable pin change interrupt on a pin. In most cases implementation should provide actual interrupt implementaiton and cache data for the user.
gpio_disable_pcint(pin) | disable pin change interrupt for a pin. 
uint8_t gpio_get_status(gpio_pin_t pin, timestamp_t *ch_up, timestamp_t *ch_down) | if implementation provides means to measure pulse widths of pulses inputted into the pin then this method provides means to read this data. The return value should indicate whether last event was pin going high or going low. 

Example usage
--------------------

```
	gpio_init();
		while(1){
			gpio_write_pin(GPIO_PB0, 1);
			delay_ms(500);
			gpio_write_pin(GPIO_PB0, 0);
			delay_ms(500);
		}
	}
```

I2C / two wire interface
----------------------------
Martin K. Schröder | info@fortmax.se

Files:

* arch/manufacturer/model/twi.h
* arch/twi.h

Public interface
----------------

The public interface used by the i2c bus is packet_interface. This is because i2c is a protocol based state machine that expects some standard data to operate. In this respect it operates just like any packet interface - it sends data buffers and receives data into a buffer. One special case that takes the point home is this: i2c devices sometimes expect a write operation followed by a repeated start signal and then a read operation. This sequence is used to read values from an i2c device. Using packet interface allows us to model this behaviour since it has begin(), end() write() and read() methods. Serial interface would be inappropriate here.


| Interface method | Corresponding twi action |
|------------------|--------------------------|
void 					(*begin)(struct packet_interface *self) | must be called every time you want to start sending data. This call allows the driver to power on the device and prepare it for accepting new data.
void 					(*end)(struct packet_interface *self) | must be called when you do not intend to send more data for a while. This method signals the driver to release the bus to other devices since packet interfaces usually share underlying medium. It is also a good place to tell the other side that we are done transmitting data. 
uint32_t			(*write)(struct packet_interface *self, const uint8_t *data, uint16_t max_sz) | writes a packet to the device the max_sz parameter tells the device how big the packet is. The function can return before the data is actually sent. In that case the device will be busy and will not accept any data until the previous data has been sent
uint32_t			(*read)(struct packet_interface *self, uint8_t *data, uint16_t max_sz) | reads a packet from the device. May return before the operation completes! max_sz denotes maximum number of bytes that are read. If a packet that arrives in hardware is larger than max_sz then the function reads in max_sz bytes and returns an error in top 16 bits of the return value. The bottom 16 bits are number of bytes that have been read. You must always check status to see if previous operation has been completed before you make any changes to passed parameters because the method accesses the data directly and if you for example exit from a function where data is a stack variable without making sure that the operation has completed, the result may be a crash because the driver is not mandated to block until the data has been received. 
void					(*sync)(struct packet_interface *self) | instructs the hardware to send all the data it has in it's buffers and waits for the hardware to complete as well as makes sure that all pending operations have completed before exiting. 
uint16_t 			(*packets_available)(struct packet_interface *self) | returns the number of packets that are waiting to be read using getn. If a read operation is already in progress, this call should return one less packets or zero in the case where only one packet can be received at a time. 


Implementation macro guidelines
----------------------

| Hardware method | Description |
|-----------------|-------------|
twi0_init(speed) | initializes twi peripheral to run at given clock speed
twi0_begin() | must be called when user is about to send a packet. 
twi0_end(void) | must be called when you do not intend to use the peripheral any more. It also waits for all previous operations to finish before returning so it can be used as way to sync with the peripheral. 
twi0_start_write(uint8_t *data, uint8_t data_sz) | starts a write operation on the bus. This method may return directly but the operation may be done in the background. The buffer that is supplied is used directly in order to save memory so it must not be destroyed! 
twi0_start_read(uint8_t *data, uint8_t data_sz) | starts a read operation and works much like the start_read() method. 
twi0_busy(void) | checks if twi is busy processing a transaction
twi0_success(void) | checks whether last operation completed successfully

Example usage
--------------------

```
char buffer[] = {DEVICE_ADDRESS, 'H', 'e', 'l', 'l', 'o'}; 
twi0_init(100000);
twi0_begin();
twi0_start_write(buffer, 6);
twi0_start_read(buffer, 6); // will read data into buffer starting at buffer[1].. 
twi0_end()
```

PWM peripheral interface
----------------------------
Martin K. Schröder | info@fortmax.se

Files:

* arch/manufacturer/model/pwm.h
* arch/pwm.h

Public interface
----------------

PWM interface is for controlling pwm hardware. Usually it would be built in, timer driven pwm channels, but the system does not limit you to just on board pwm channel You could just as easily have a driver for an i2c or spi pwm controller export this kind of interface and this would allow you to pass it to any component that requires a pwm interface (such as for example a motor speed controller). 

The basic pulse width modulator interface consists of following methods: 

| Interface method | Corresponding twi action |
|------------------|--------------------------|
uint16_t 		(*set_channel_duty)(struct pwm_interface *self, uint8_t channel, uint16_t value_us) | Sets channel "on" time to value specified in microseconds. A pwm controller can have several channels. Channel id is implementation specific id of the channel. returns actual duty cycle time that has been set. 
uint16_t 		(*set_channel_period)(struct pwm_interface *self, uint8_t channel, uint16_t value_us) | Occasionally it may be beneficial to change period time of the pwm signal. Implementation should pick the prescaler value that gives the closest match to the specified period. This does not guarantee that the period value will be exact. but implementation should try to make it as exact as possible. returns actual period that has been set. 


Implementation macro guidelines
----------------------

| Hardware method | Description |
|-----------------|-------------|
pwm0_enable() | enable pwm channel and configure it to settings most commonly seen in hobby controller context: ie pulse width between 0 and 2000 usec. The frequency is also kept as high as possible. Some servos may not be able to handle higher update rate but this can be fixed later if it becomes an issue. 
pwm0_set(speed) | sets pulse width in microseconds. 

Example usage
--------------------

pwm0_init();
pwm1_init();

pwm0_set(1500); // half throttle
pwm0_set(1000); // zero throttle
pwm0_set(2000); // full throttle

SPI peripheral interface
----------------------------
Martin K. Schröder | info@fortmax.se

Files:

* arch/manufacturer/model/spi.h
* arch/spi.h

Public interface
----------------

SPI peripherals can be accessed by using standard serial_interface. A method for each peripheral must be provided: spi0_get_serial_interface() that returns struct serial_interface.


Implementation macro guidelines
----------------------

| Hardware method | Description |
|-----------------|-------------|
hwspi0_set_clock(spi_rate) | sets spi clock rate. Implementation must provide appropriate devinces along the form of SPI_CLOCK_DIVXXX. 
hwspi0_set_mode(spi_mode) | sets spi mode (whether it's sampled on falling or leading edge of the clock. Valid modes should be SPI_MODE0, SPI_MODE1, SPI_MODE2 and SPI_MODE3. 
hwspi0_master() | configure this interface as spi master
hwspi0_slave() | configure this interface as spi slave
hwspi0_order_lsb_first() | sets order to lsb transmitted first (bit order)
hwspi0_order_msb_first() | sets order with msb first
hwspi0_interrupt_enable() | enables spi interrupt
hwspi0_interrupt_disable() | disables spi interrupt
hwspi0_enable() | enables spi interface
hwspi0_disable() | disables spi interface
hwspi0_config_gpio() | configures gpio pins for this spi interface (ie input/outputs etc). 
hwspi0_wait_for_transmit_complete() | waits for transmission to finish
hwspi0_error_collision() | checks collision flag (set if data is written before previous data has been sent)
hwspi0_init_default() | initializes spi peripheral with default settings. Usually SPI_MODE0, interrupt disabled, msb first, master, spi enabled. Clock is set to 1mhz (or something close, depending on used hardware) 
hwspi0_putc(ch) | writes a character to spi, does not 
hwspi0_getc(ch) | reads previously received character. since spi transmits and receives at the same time, the character is usually cached by implementation and you can then read it using this method. 
hwspi0_transfer(ch) | combines write and read into one op. Returns character received. 


Example usage
--------------------

```
hwspi0_init_default();

uint8_t data = hwspi0_transfer('X'); 
```
Timers and tick counters
----------------------------
Martin K. Schröder | info@fortmax.se

Files:

* arch/manufacturer/model/time.h
* arch/time.h

Intro
-----

It is often necessary for implementation to provide a timer/counter for counting cpu clock cycles because this is the only way to do fairly exact timing when interrupts are enabled. More complex chips usually have a dedicated timer for this and an instruction to read clock counter. But for architectures that do not have this functionality, one of the timers needs to be used.

Usage of clock counter
---------------

In the rest of the system clock counter value can be used in many ways - from simple delays to asynchronous events. If you disable this functionality then some drivers may stop working, but ideally they would not even compile. There is a special config field called CONFIG_TIMESTAMP_COUNTER that enables timestamping functionality and drivers that need this functionality should be configured in the corresponding KConfig file to depend on it being set. 

Public interface
----------------

Timer counter currently does not export interfaces. This may change when drivers would require an abstract timer object. For now, timers are mostly only used directly by drivers in the arch layer. While higher level drivers mostly only use timestamping to calculate delays and timeouts. 


Implementation guidelines
----------------------

| Hardware method | Description |
|-----------------|-------------|
timestamp_init() | sets up timestamping counter to start counting. This configures one of the hardware timers to run at a frequency that is preferably exactly 1Mhz. But it may be 2Mhz or 8Mhz.. the value is implementation specific and the timestamp value returned by this method is in ticks count. So you need to convert it to microseconds in order to see what it is in microseconds.
timestamp_now() | gets current timestamp value in ticks. The value is ticks from cpu start. but remember that the value will wrap around after about 70 minutes. So do not measure overly long delays using this counter. The standard use is to capture the counter, do something and then check whether certain amount of time has elapsed. Functions below help you do this. 
timestamp_ticks_to_us(ticks) | converts ticks value to microseconds. 
timestamp_us_to_ticks(us) | converts microseconds to equivalent number of ticks
timestamp_before(unknown, known) | checks if unknown is before known. This function is required to handle overflow of the ticks counter correctly. 
timestamp_after(a,b) | checks if a is after b, also overflow safe
timestamp_from_now_us(us) | calculates a timeout value a number of microseconds in the future
timestamp_expired(timeout) | checks if a previously set timeout has expired
timestamp_delay_us(timestamp_t usec) | equivalent to busy loop delay, but more exact when interrupts are enabled. 
delay_us(usec) | a generic method that can be pinted directly to timestamp_delay_us
timestamp_ticks_since(timestamp) | returns ticks that have elapsed from some timestamp

There are more timer hardware specific methods but they will not be covered here for now. Instead, have a look at implementation specific time.h file to get an idea. 

Example usage
--------------------

```
timestamp_init();
timeout_t timeout = timeout_from_now(1000000); // 1s timeout
while(1){
	// do work
	if(timeout_expired(timeout))
		break; // will stop after 1 second
}
```

UART serial interface
----------------------------
Martin K. Schröder | info@fortmax.se

Files:

* arch/manufacturer/model/uart.h
* arch/uart.h

Intro
-----

As with many other peripherals, a chip can have several uarts. All uarts should export a serial_interface for generic access. 


Public interface
----------------

Check out definition of struct serial_interface in arch/interface.h 

Implementation guidelines
----------------------

Implementation is as always free to either use buffered interrupt driven uart or simple non buffered uart. The advantage of implementing a buffered uart is that all write operations can return to higher level code much quicker so that application can carry on while uart sends the data in the background. So it is always preferable to at least have a small buffer. 

| Hardware method | Description |
|-----------------|-------------|
 | 

Example usage
--------------------

It is up to higher level code to provide printf functionality. However, uart code may export a file descriptor for the uart making it possible to use standard fprintf() functionality pretty easily. If this is done, then global uart file descriptors are exported and named uartX_fd for each available uart. This removes the need to write custom printf functions because we can just use libc. 

```
uart0_init(32400);

// accessing directly
uart0_putc('X');

// using an interface
struct serial_interface serial = uart0_get_serial_interface();
char buffer[] = "Hello World!"; 
serial.putn(&serial, buffer, strlen(buffer));

// using file descriptor
fprintf(uart0_fd, "Hello %s\n", "World!"); 
```
